"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionPool = void 0;

var mysql = _interopRequireWildcard(require("mysql"));

var _Sql = require("./Sql");

var _cliHighlight = _interopRequireDefault(require("cli-highlight"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function typeCast(field, next) {
  switch (field.type) {
    case 'DATE':
    case 'DATETIME':
    case 'DATETIME2':
    case 'NEWDATE':
    case 'TIMESTAMP':
    case 'TIMESTAMP2':
      return field.string();

    case 'LONGLONG':
      const numberString = field.string();
      return numberString === null ? null : BigInt(numberString);

    case 'BIT':
      if (field.length === 1) {
        const buf = field.buffer();
        return buf === null ? null : buf[0] === 1;
      }

      break;
  }

  return next();
}

class ConnectionPool {
  constructor(config) {
    this.config = {
      timezone: 'Z',
      charset: 'utf8mb4',
      typeCast,
      ...config
    };
    let {
      sqlMode,
      foreignKeyChecks,
      safeUpdates,
      printQueries,
      initSql,
      ...other
    } = this.config;
    this.pool = mysql.createPool(other);
    const connQueries = initSql ? [...initSql] : [];

    if (sqlMode != null) {
      connQueries.push(_Sql.sql`SET sql_mode=${Array.isArray(sqlMode) ? sqlMode.join(',') : sqlMode}`);
    }

    if (foreignKeyChecks != null) {
      connQueries.push(_Sql.sql`SET foreign_key_checks=${foreignKeyChecks ? 1 : 0}`);
    }

    if (safeUpdates) {
      connQueries.push(_Sql.sql`SET sql_safe_updates=${safeUpdates ? 1 : 0}`);
    }

    if (connQueries.length) {
      this.pool.on('connection', _conn => {
        const conn = this._wrap(_conn);

        for (const query of connQueries) {
          conn.query(query);
        }
      });
    }
  }

  query(query) {
    return this.withConnection(conn => conn.query(query));
  }

  exec(query) {
    return this.withConnection(conn => conn.query(query));
  }

  async *stream(query) {
    const sql = query.toSqlString();

    if (this.config.printQueries) {
      const hisql = (0, _cliHighlight.default)(sql, {
        language: 'sql',
        ignoreIllegals: true
      });
      console.log(hisql);
    }

    let results = [];
    let resolve;
    let promise = new Promise(r => resolve = r);
    let done = false;
    this.pool.query(sql).on('error', err => {
      throw err;
    }).on('result', row => {
      resolve();
      results.push(row);
      promise = new Promise(r => resolve = r);
    }).on('end', () => {
      done = true;
    });

    while (!done) {
      await promise;
      yield* results;
      results = [];
    }
  }

  withConnection(callback) {
    return new Promise((resolve, reject) => {
      this.pool.getConnection(async (err, conn) => {
        if (err) return reject(err);

        try {
          resolve(callback(this._wrap(conn)));
        } finally {
          conn.release();
        }
      });
    });
  }

  transaction(callback) {
    if (Array.isArray(callback)) {
      return this.transaction(async conn => {
        const results = await Promise.allSettled(callback.map(sql => conn.query(sql)));
        const mapped = zip(callback, results).map((x, i) => ({
          index: i,
          query: x[0],
          result: x[1]
        }));
        const errors = mapped.filter(r => r.result.status === 'rejected');
        if (errors.length) throw Error(`${errors.length} quer${errors.length === 1 ? 'y' : 'ies'} failed:${errors.map(err => `\n[${err.index}] ${err.query.toSqlString()} :: ${err.result.reason}`).join('')}`);
        return results;
      });
    }

    return this.withConnection(async conn => {
      await conn.query(_Sql.sql`START TRANSACTION`);
      let result;

      try {
        result = await callback(conn);
      } catch (err) {
        await conn.query(_Sql.sql`ROLLBACK`);
        throw err;
      }

      await conn.query(_Sql.sql`COMMIT`);
      return result;
    });
  }

  _wrap(conn) {
    return new PoolConnection(conn, !!this.config.printQueries);
  }

  close() {
    return new Promise((resolve, reject) => {
      this.pool.end(err => {
        if (err) return reject(err);
        resolve();
      });
    });
  }

}

exports.ConnectionPool = ConnectionPool;

function zip(a, b) {
  if (a.length !== b.length) throw new Error("Cannot zip arrays; lengths differ");
  return a.map((x, i) => [x, b[i]]);
}

class PoolConnection {
  constructor(conn, printQueries) {
    this.conn = conn;
    this.printQueries = printQueries;
  }

  query(query) {
    return new Promise((resolve, reject) => {
      const sql = query.toSqlString();

      if (this.printQueries) {
        const hisql = (0, _cliHighlight.default)(sql, {
          language: 'sql',
          ignoreIllegals: true
        });
        console.log(hisql);
      }

      this.conn.query(sql, (error, results, fields) => {
        if (error) return reject(error);
        resolve(results);
      });
    });
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db25uZWN0aW9uUG9vbC50cyJdLCJuYW1lcyI6WyJ0eXBlQ2FzdCIsImZpZWxkIiwibmV4dCIsInR5cGUiLCJzdHJpbmciLCJudW1iZXJTdHJpbmciLCJCaWdJbnQiLCJsZW5ndGgiLCJidWYiLCJidWZmZXIiLCJDb25uZWN0aW9uUG9vbCIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwidGltZXpvbmUiLCJjaGFyc2V0Iiwic3FsTW9kZSIsImZvcmVpZ25LZXlDaGVja3MiLCJzYWZlVXBkYXRlcyIsInByaW50UXVlcmllcyIsImluaXRTcWwiLCJvdGhlciIsInBvb2wiLCJteXNxbCIsImNyZWF0ZVBvb2wiLCJjb25uUXVlcmllcyIsInB1c2giLCJzcWwiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwib24iLCJfY29ubiIsImNvbm4iLCJfd3JhcCIsInF1ZXJ5Iiwid2l0aENvbm5lY3Rpb24iLCJleGVjIiwic3RyZWFtIiwidG9TcWxTdHJpbmciLCJoaXNxbCIsImxhbmd1YWdlIiwiaWdub3JlSWxsZWdhbHMiLCJjb25zb2xlIiwibG9nIiwicmVzdWx0cyIsInJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsInIiLCJkb25lIiwiZXJyIiwicm93IiwiY2FsbGJhY2siLCJyZWplY3QiLCJnZXRDb25uZWN0aW9uIiwicmVsZWFzZSIsInRyYW5zYWN0aW9uIiwiYWxsU2V0dGxlZCIsIm1hcCIsIm1hcHBlZCIsInppcCIsIngiLCJpIiwiaW5kZXgiLCJyZXN1bHQiLCJlcnJvcnMiLCJmaWx0ZXIiLCJzdGF0dXMiLCJFcnJvciIsInJlYXNvbiIsIlBvb2xDb25uZWN0aW9uIiwiY2xvc2UiLCJlbmQiLCJhIiwiYiIsImVycm9yIiwiZmllbGRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7Ozs7Ozs7O0FBeURBLFNBQVNBLFFBQVQsQ0FBa0JDLEtBQWxCLEVBQW9DQyxJQUFwQyxFQUF1RDtBQUNuRCxVQUFRRCxLQUFLLENBQUNFLElBQWQ7QUFDSSxTQUFLLE1BQUw7QUFDQSxTQUFLLFVBQUw7QUFDQSxTQUFLLFdBQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLFdBQUw7QUFDQSxTQUFLLFlBQUw7QUFFSSxhQUFPRixLQUFLLENBQUNHLE1BQU4sRUFBUDs7QUFDSixTQUFLLFVBQUw7QUFDSSxZQUFNQyxZQUFZLEdBQUdKLEtBQUssQ0FBQ0csTUFBTixFQUFyQjtBQUNBLGFBQU9DLFlBQVksS0FBSyxJQUFqQixHQUF3QixJQUF4QixHQUErQkMsTUFBTSxDQUFDRCxZQUFELENBQTVDOztBQUNKLFNBQUssS0FBTDtBQUNJLFVBQUlKLEtBQUssQ0FBQ00sTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUNwQixjQUFNQyxHQUFHLEdBQUdQLEtBQUssQ0FBQ1EsTUFBTixFQUFaO0FBQ0EsZUFBT0QsR0FBRyxLQUFLLElBQVIsR0FBZSxJQUFmLEdBQXNCQSxHQUFHLENBQUMsQ0FBRCxDQUFILEtBQVcsQ0FBeEM7QUFDSDs7QUFDRDtBQWpCUjs7QUFtQkEsU0FBT04sSUFBSSxFQUFYO0FBQ0g7O0FBRU0sTUFBTVEsY0FBTixDQUFxQjtBQUl4QkMsRUFBQUEsV0FBVyxDQUFDQyxNQUFELEVBQXFCO0FBQzVCLFNBQUtBLE1BQUwsR0FBYztBQUNWQyxNQUFBQSxRQUFRLEVBQUUsR0FEQTtBQUVWQyxNQUFBQSxPQUFPLEVBQUUsU0FGQztBQUdWZCxNQUFBQSxRQUhVO0FBSVYsU0FBR1k7QUFKTyxLQUFkO0FBTUEsUUFBSTtBQUFDRyxNQUFBQSxPQUFEO0FBQVNDLE1BQUFBLGdCQUFUO0FBQTBCQyxNQUFBQSxXQUExQjtBQUFzQ0MsTUFBQUEsWUFBdEM7QUFBbURDLE1BQUFBLE9BQW5EO0FBQTJELFNBQUdDO0FBQTlELFFBQXVFLEtBQUtSLE1BQWhGO0FBRUEsU0FBS1MsSUFBTCxHQUFZQyxLQUFLLENBQUNDLFVBQU4sQ0FBaUJILEtBQWpCLENBQVo7QUFFQSxVQUFNSSxXQUFXLEdBQUdMLE9BQU8sR0FBRyxDQUFDLEdBQUdBLE9BQUosQ0FBSCxHQUFrQixFQUE3Qzs7QUFDQSxRQUFHSixPQUFPLElBQUksSUFBZCxFQUFvQjtBQUNoQlMsTUFBQUEsV0FBVyxDQUFDQyxJQUFaLENBQWlCQyxRQUFJLGdCQUFlQyxLQUFLLENBQUNDLE9BQU4sQ0FBY2IsT0FBZCxJQUEwQkEsT0FBTyxDQUFDYyxJQUFSLENBQWEsR0FBYixDQUExQixHQUE4Q2QsT0FBUSxFQUExRjtBQUNIOztBQUNELFFBQUdDLGdCQUFnQixJQUFJLElBQXZCLEVBQTZCO0FBQ3pCUSxNQUFBQSxXQUFXLENBQUNDLElBQVosQ0FBaUJDLFFBQUksMEJBQXlCVixnQkFBZ0IsR0FBRyxDQUFILEdBQU8sQ0FBRSxFQUF2RTtBQUNIOztBQUNELFFBQUdDLFdBQUgsRUFBZ0I7QUFDWk8sTUFBQUEsV0FBVyxDQUFDQyxJQUFaLENBQWlCQyxRQUFJLHdCQUF1QlQsV0FBVyxHQUFHLENBQUgsR0FBTyxDQUFFLEVBQWhFO0FBQ0g7O0FBQ0QsUUFBR08sV0FBVyxDQUFDakIsTUFBZixFQUF1QjtBQUNuQixXQUFLYyxJQUFMLENBQVVTLEVBQVYsQ0FBYSxZQUFiLEVBQTRCQyxLQUFELElBQTRCO0FBQ25ELGNBQU1DLElBQUksR0FBRyxLQUFLQyxLQUFMLENBQVdGLEtBQVgsQ0FBYjs7QUFDQSxhQUFJLE1BQU1HLEtBQVYsSUFBbUJWLFdBQW5CLEVBQWdDO0FBQzVCUSxVQUFBQSxJQUFJLENBQUNFLEtBQUwsQ0FBV0EsS0FBWDtBQUNIO0FBQ0osT0FMRDtBQU1IO0FBQ0o7O0FBRURBLEVBQUFBLEtBQUssQ0FBNENBLEtBQTVDLEVBQWdGO0FBQ2pGLFdBQU8sS0FBS0MsY0FBTCxDQUFvQkgsSUFBSSxJQUFJQSxJQUFJLENBQUNFLEtBQUwsQ0FBV0EsS0FBWCxDQUE1QixDQUFQO0FBQ0g7O0FBRURFLEVBQUFBLElBQUksQ0FBQ0YsS0FBRCxFQUFvQztBQUNwQyxXQUFPLEtBQUtDLGNBQUwsQ0FBb0JILElBQUksSUFBSUEsSUFBSSxDQUFDRSxLQUFMLENBQVdBLEtBQVgsQ0FBNUIsQ0FBUDtBQUNIOztBQUVELFNBQU9HLE1BQVAsQ0FBNERILEtBQTVELEVBQWdIO0FBQzVHLFVBQU1SLEdBQUcsR0FBR1EsS0FBSyxDQUFDSSxXQUFOLEVBQVo7O0FBRUEsUUFBSSxLQUFLMUIsTUFBTCxDQUFZTSxZQUFoQixFQUE4QjtBQUMxQixZQUFNcUIsS0FBSyxHQUFHLDJCQUFVYixHQUFWLEVBQWU7QUFBQ2MsUUFBQUEsUUFBUSxFQUFFLEtBQVg7QUFBa0JDLFFBQUFBLGNBQWMsRUFBRTtBQUFsQyxPQUFmLENBQWQ7QUFDQUMsTUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVlKLEtBQVo7QUFDSDs7QUFFRCxRQUFJSyxPQUFrQixHQUFHLEVBQXpCO0FBQ0EsUUFBSUMsT0FBSjtBQUNBLFFBQUlDLE9BQU8sR0FBRyxJQUFJQyxPQUFKLENBQVlDLENBQUMsSUFBSUgsT0FBTyxHQUFHRyxDQUEzQixDQUFkO0FBQ0EsUUFBSUMsSUFBSSxHQUFHLEtBQVg7QUFFQSxTQUFLNUIsSUFBTCxDQUFVYSxLQUFWLENBQWdCUixHQUFoQixFQUNLSSxFQURMLENBQ1EsT0FEUixFQUNpQm9CLEdBQUcsSUFBSTtBQUNoQixZQUFNQSxHQUFOO0FBQ0gsS0FITCxFQUlLcEIsRUFKTCxDQUlRLFFBSlIsRUFJa0JxQixHQUFHLElBQUk7QUFDakJOLE1BQUFBLE9BQU87QUFDUEQsTUFBQUEsT0FBTyxDQUFDbkIsSUFBUixDQUFhMEIsR0FBYjtBQUNBTCxNQUFBQSxPQUFPLEdBQUcsSUFBSUMsT0FBSixDQUFZQyxDQUFDLElBQUlILE9BQU8sR0FBR0csQ0FBM0IsQ0FBVjtBQUNILEtBUkwsRUFTS2xCLEVBVEwsQ0FTUSxLQVRSLEVBU2UsTUFBTTtBQUNibUIsTUFBQUEsSUFBSSxHQUFHLElBQVA7QUFDSCxLQVhMOztBQWFBLFdBQU8sQ0FBQ0EsSUFBUixFQUFjO0FBQ1YsWUFBTUgsT0FBTjtBQUNBLGFBQU9GLE9BQVA7QUFDQUEsTUFBQUEsT0FBTyxHQUFHLEVBQVY7QUFDSDtBQUNKOztBQUVEVCxFQUFBQSxjQUFjLENBQVVpQixRQUFWLEVBQWlGO0FBQzNGLFdBQU8sSUFBSUwsT0FBSixDQUFZLENBQUNGLE9BQUQsRUFBVVEsTUFBVixLQUFxQjtBQUNwQyxXQUFLaEMsSUFBTCxDQUFVaUMsYUFBVixDQUF3QixPQUFPSixHQUFQLEVBQVlsQixJQUFaLEtBQXFCO0FBQ3pDLFlBQUlrQixHQUFKLEVBQVMsT0FBT0csTUFBTSxDQUFDSCxHQUFELENBQWI7O0FBQ1QsWUFBSTtBQUNBTCxVQUFBQSxPQUFPLENBQUNPLFFBQVEsQ0FBQyxLQUFLbkIsS0FBTCxDQUFXRCxJQUFYLENBQUQsQ0FBVCxDQUFQO0FBQ0gsU0FGRCxTQUVVO0FBQ05BLFVBQUFBLElBQUksQ0FBQ3VCLE9BQUw7QUFDSDtBQUNKLE9BUEQ7QUFRSCxLQVRNLENBQVA7QUFVSDs7QUFFREMsRUFBQUEsV0FBVyxDQUFVSixRQUFWLEVBQTZGO0FBQ3BHLFFBQUd6QixLQUFLLENBQUNDLE9BQU4sQ0FBY3dCLFFBQWQsQ0FBSCxFQUE0QjtBQUN4QixhQUFPLEtBQUtJLFdBQUwsQ0FBc0IsTUFBTXhCLElBQU4sSUFBYztBQUN2QyxjQUFNWSxPQUFPLEdBQUcsTUFBTUcsT0FBTyxDQUFDVSxVQUFSLENBQW1CTCxRQUFRLENBQUNNLEdBQVQsQ0FBYWhDLEdBQUcsSUFBSU0sSUFBSSxDQUFDRSxLQUFMLENBQVdSLEdBQVgsQ0FBcEIsQ0FBbkIsQ0FBdEI7QUFDQSxjQUFNaUMsTUFBTSxHQUFHQyxHQUFHLENBQUNSLFFBQUQsRUFBV1IsT0FBWCxDQUFILENBQXVCYyxHQUF2QixDQUEyQixDQUFDRyxDQUFELEVBQUdDLENBQUgsTUFBVTtBQUNoREMsVUFBQUEsS0FBSyxFQUFFRCxDQUR5QztBQUVoRDVCLFVBQUFBLEtBQUssRUFBRTJCLENBQUMsQ0FBQyxDQUFELENBRndDO0FBR2hERyxVQUFBQSxNQUFNLEVBQUVILENBQUMsQ0FBQyxDQUFEO0FBSHVDLFNBQVYsQ0FBM0IsQ0FBZjtBQUtBLGNBQU1JLE1BQU0sR0FBR04sTUFBTSxDQUFDTyxNQUFQLENBQWNsQixDQUFDLElBQUlBLENBQUMsQ0FBQ2dCLE1BQUYsQ0FBU0csTUFBVCxLQUFvQixVQUF2QyxDQUFmO0FBQ0EsWUFBR0YsTUFBTSxDQUFDMUQsTUFBVixFQUFrQixNQUFNNkQsS0FBSyxDQUFFLEdBQUVILE1BQU0sQ0FBQzFELE1BQU8sUUFBTzBELE1BQU0sQ0FBQzFELE1BQVAsS0FBa0IsQ0FBbEIsR0FBc0IsR0FBdEIsR0FBNEIsS0FBTSxXQUFVMEQsTUFBTSxDQUFDUCxHQUFQLENBQVdSLEdBQUcsSUFBSyxNQUFLQSxHQUFHLENBQUNhLEtBQU0sS0FBSWIsR0FBRyxDQUFDaEIsS0FBSixDQUFVSSxXQUFWLEVBQXdCLE9BQU9ZLEdBQUcsQ0FBQ2MsTUFBTCxDQUFvQkssTUFBTyxFQUEvRixFQUFrR3hDLElBQWxHLENBQXVHLEVBQXZHLENBQTJHLEVBQWhMLENBQVg7QUFDbEIsZUFBT2UsT0FBUDtBQUNILE9BVk0sQ0FBUDtBQVdIOztBQUNELFdBQU8sS0FBS1QsY0FBTCxDQUFvQixNQUFNSCxJQUFOLElBQWM7QUFDckMsWUFBTUEsSUFBSSxDQUFDRSxLQUFMLENBQVdSLFFBQUksbUJBQWYsQ0FBTjtBQUNBLFVBQUlzQyxNQUFKOztBQUNBLFVBQUk7QUFDQUEsUUFBQUEsTUFBTSxHQUFHLE1BQU1aLFFBQVEsQ0FBQ3BCLElBQUQsQ0FBdkI7QUFDSCxPQUZELENBRUUsT0FBTWtCLEdBQU4sRUFBVztBQUNULGNBQU1sQixJQUFJLENBQUNFLEtBQUwsQ0FBV1IsUUFBSSxVQUFmLENBQU47QUFDQSxjQUFNd0IsR0FBTjtBQUNIOztBQUNELFlBQU1sQixJQUFJLENBQUNFLEtBQUwsQ0FBV1IsUUFBSSxRQUFmLENBQU47QUFDQSxhQUFPc0MsTUFBUDtBQUNILEtBWE0sQ0FBUDtBQVlIOztBQUVPL0IsRUFBQUEsS0FBUixDQUFjRCxJQUFkLEVBQXFDO0FBQ2pDLFdBQU8sSUFBSXNDLGNBQUosQ0FBbUJ0QyxJQUFuQixFQUF5QixDQUFDLENBQUMsS0FBS3BCLE1BQUwsQ0FBWU0sWUFBdkMsQ0FBUDtBQUNIOztBQUVEcUQsRUFBQUEsS0FBSyxHQUFHO0FBQ0osV0FBTyxJQUFJeEIsT0FBSixDQUFZLENBQUNGLE9BQUQsRUFBVVEsTUFBVixLQUFxQjtBQUNwQyxXQUFLaEMsSUFBTCxDQUFVbUQsR0FBVixDQUFjdEIsR0FBRyxJQUFJO0FBQ2pCLFlBQUlBLEdBQUosRUFBUyxPQUFPRyxNQUFNLENBQUNILEdBQUQsQ0FBYjtBQUNUTCxRQUFBQSxPQUFPO0FBQ1YsT0FIRDtBQUlILEtBTE0sQ0FBUDtBQU1IOztBQWhJdUI7Ozs7QUFtSTVCLFNBQVNlLEdBQVQsQ0FBa0JhLENBQWxCLEVBQTBCQyxDQUExQixFQUFnRDtBQUM1QyxNQUFHRCxDQUFDLENBQUNsRSxNQUFGLEtBQWFtRSxDQUFDLENBQUNuRSxNQUFsQixFQUEwQixNQUFNLElBQUk2RCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUMxQixTQUFPSyxDQUFDLENBQUNmLEdBQUYsQ0FBTSxDQUFDRyxDQUFELEVBQUdDLENBQUgsS0FBUyxDQUFDRCxDQUFELEVBQUdhLENBQUMsQ0FBQ1osQ0FBRCxDQUFKLENBQWYsQ0FBUDtBQUNIOztBQUVELE1BQU1RLGNBQU4sQ0FBcUI7QUFFakIzRCxFQUFBQSxXQUFXLENBQWtCcUIsSUFBbEIsRUFBMERkLFlBQTFELEVBQWlGO0FBQUEsU0FBL0RjLElBQStELEdBQS9EQSxJQUErRDtBQUFBLFNBQXZCZCxZQUF1QixHQUF2QkEsWUFBdUI7QUFFM0Y7O0FBRURnQixFQUFBQSxLQUFLLENBQUNBLEtBQUQsRUFBK0I7QUFDaEMsV0FBTyxJQUFJYSxPQUFKLENBQVksQ0FBQ0YsT0FBRCxFQUFVUSxNQUFWLEtBQXFCO0FBQ3BDLFlBQU0zQixHQUFHLEdBQUdRLEtBQUssQ0FBQ0ksV0FBTixFQUFaOztBQUNBLFVBQUksS0FBS3BCLFlBQVQsRUFBdUI7QUFDbkIsY0FBTXFCLEtBQUssR0FBRywyQkFBVWIsR0FBVixFQUFlO0FBQUNjLFVBQUFBLFFBQVEsRUFBRSxLQUFYO0FBQWtCQyxVQUFBQSxjQUFjLEVBQUU7QUFBbEMsU0FBZixDQUFkO0FBQ0FDLFFBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZSixLQUFaO0FBQ0g7O0FBQ0QsV0FBS1AsSUFBTCxDQUFVRSxLQUFWLENBQWdCUixHQUFoQixFQUFxQixDQUFDaUQsS0FBRCxFQUFRL0IsT0FBUixFQUFpQmdDLE1BQWpCLEtBQTRCO0FBQzdDLFlBQUlELEtBQUosRUFBVyxPQUFPdEIsTUFBTSxDQUFDc0IsS0FBRCxDQUFiO0FBQ1g5QixRQUFBQSxPQUFPLENBQUNELE9BQUQsQ0FBUDtBQUNILE9BSEQ7QUFJSCxLQVZNLENBQVA7QUFXSDs7QUFsQmdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbXlzcWwgZnJvbSAnbXlzcWwnO1xuaW1wb3J0IHtQb29sQ29uZmlnIGFzIF9Qb29sQ29uZmlnLCBQb29sLCBUeXBlQ2FzdCBhcyBfVHlwZUNhc3QsIEZpZWxkSW5mbyBhcyBfRmllbGRJbmZvLCBUeXBlcyBhcyBfVHlwZXN9IGZyb20gXCJteXNxbFwiO1xuaW1wb3J0IHtzcWwsIFNxbEZyYWd9IGZyb20gJy4vU3FsJztcbmltcG9ydCBoaWdobGlnaHQgZnJvbSAnY2xpLWhpZ2hsaWdodCc7XG5pbXBvcnQge2luc3BlY3R9IGZyb20gXCJ1dGlsXCI7XG5pbXBvcnQge0dlb21ldHJ5VHlwZX0gZnJvbSBcIm15c3FsXCI7XG5pbXBvcnQgU3FsTW9kZSBmcm9tIFwiLi9TcWxNb2RlXCI7XG5pbXBvcnQge1Bvb2xDb25uZWN0aW9uIGFzIF9Qb29sQ29ubmVjdGlvbn0gZnJvbSBcIm15c3FsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9vbENvbmZpZyBleHRlbmRzIE9taXQ8X1Bvb2xDb25maWcsJ3R5cGVDYXN0J3wnc3VwcG9ydEJpZ051bWJlcnMnfCdiaWdOdW1iZXJTdHJpbmdzJz4ge1xuICAgIC8qKlxuICAgICAqIFByaW50IFNRTCBxdWVyaWVzIHRvIFNURE9VVCBiZWZvcmUgZXhlY3V0aW5nIHRoZW0uXG4gICAgICovXG4gICAgcHJpbnRRdWVyaWVzPzogYm9vbGVhblxuICAgIHR5cGVDYXN0PzogKGZpZWxkOiBGaWVsZEluZm8sIG5leHQ6IE5leHRGbikgPT4gYW55LFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFNldCBpbiBteS5jbmYgdW5kZXIgW215c3FsZF1cbiAgICAgKi9cbiAgICBzcWxNb2RlPzogU3FsTW9kZVtdfHN0cmluZ3xudWxsLFxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGZvcmVpZ24ga2V5IGNoZWNrcyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi4gTWF5IGVhc2UgbWlncmF0aW9uIHNjcmlwdHMsIGJ1dCBub3QgcmVjb21tZW5kZWRcbiAgICAgKiBmb3IgcHJvZHVjdGlvbiB1c2FnZS5cbiAgICAgKi9cbiAgICBmb3JlaWduS2V5Q2hlY2tzPzogYm9vbGVhbnxudWxsLFxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgdmFyaWFibGUgaXMgZW5hYmxlZCwgVVBEQVRFIGFuZCBERUxFVEUgc3RhdGVtZW50cyB0aGF0IGRvIG5vdCB1c2UgYSBrZXkgaW4gdGhlIFdIRVJFIGNsYXVzZSBvciBhIExJTUlUIGNsYXVzZSBwcm9kdWNlIGFuIGVycm9yLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNhdGNoIFVQREFURSBhbmQgREVMRVRFIHN0YXRlbWVudHMgd2hlcmUga2V5cyBhcmUgbm90IHVzZWQgcHJvcGVybHkgYW5kIHRoYXQgd291bGQgcHJvYmFibHkgY2hhbmdlIG9yIGRlbGV0ZSBhIGxhcmdlIG51bWJlciBvZiByb3dzLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9tYXJpYWRiLmNvbS9rYi9lbi9saWJyYXJ5L3NlcnZlci1zeXN0ZW0tdmFyaWFibGVzLyNzcWxfc2FmZV91cGRhdGVzXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3NlcnZlci1zeXN0ZW0tdmFyaWFibGVzLmh0bWwjc3lzdmFyX3NxbF9zYWZlX3VwZGF0ZXNcbiAgICAgKiBAZGVwcmVjYXRlZCBTZXQgaW4gbXkuY25mIHVuZGVyIFtteXNxbGRdXG4gICAgICovXG4gICAgc2FmZVVwZGF0ZXM/OiBib29sZWFufG51bGwsXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgU1FMIHN0YXRlbWVudHMgdG8gZXhlY3V0ZSB1cG9uIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgaW5pdFNxbD86IEFycmF5PFNxbEZyYWc+XG59XG5cbmV4cG9ydCB0eXBlIE5leHRGbiA9ICgpID0+IHZvaWRcbmV4cG9ydCB0eXBlIFR5cGVzID0ga2V5b2YgdHlwZW9mIF9UeXBlc1xuZXhwb3J0IHR5cGUgRmllbGRJbmZvID0gT21pdDxfRmllbGRJbmZvLCAndHlwZSc+ICYge1xuICAgIHR5cGU6IFR5cGVzLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIHN0cmluZygpOiBzdHJpbmcgfCBudWxsLFxuICAgIGJ1ZmZlcigpOiBCdWZmZXIgfCBudWxsLFxuICAgIGdlb21ldHJ5KCk6IEdlb21ldHJ5VHlwZSB8IG51bGwsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2tQYWNrZXQge1xuICAgIGZpZWxkQ291bnQ6IG51bWJlcixcbiAgICBhZmZlY3RlZFJvd3M6IG51bWJlcixcbiAgICBpbnNlcnRJZDogbnVtYmVyLFxuICAgIHNlcnZlclN0YXR1czogbnVtYmVyLFxuICAgIHdhcm5pbmdDb3VudDogbnVtYmVyLFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwcm90b2NvbDQxOiBib29sZWFuLFxuICAgIGNoYW5nZWRSb3dzOiBudW1iZXJcbn1cblxuXG5mdW5jdGlvbiB0eXBlQ2FzdChmaWVsZDogRmllbGRJbmZvLCBuZXh0OiBOZXh0Rm4pOiBhbnkge1xuICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICBjYXNlICdEQVRFJzpcbiAgICAgICAgY2FzZSAnREFURVRJTUUnOlxuICAgICAgICBjYXNlICdEQVRFVElNRTInOlxuICAgICAgICBjYXNlICdORVdEQVRFJzpcbiAgICAgICAgY2FzZSAnVElNRVNUQU1QJzpcbiAgICAgICAgY2FzZSAnVElNRVNUQU1QMic6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXlzcWxqcy9teXNxbCN0eXBlLWNhc3RpbmdcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5zdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnTE9OR0xPTkcnOlxuICAgICAgICAgICAgY29uc3QgbnVtYmVyU3RyaW5nID0gZmllbGQuc3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyU3RyaW5nID09PSBudWxsID8gbnVsbCA6IEJpZ0ludChudW1iZXJTdHJpbmcpO1xuICAgICAgICBjYXNlICdCSVQnOlxuICAgICAgICAgICAgaWYgKGZpZWxkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IGZpZWxkLmJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWYgPT09IG51bGwgPyBudWxsIDogYnVmWzBdID09PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG59XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uUG9vbCB7XG4gICAgcHJpdmF0ZSBwb29sOiBQb29sO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBQb29sQ29uZmlnO1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBQb29sQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgdGltZXpvbmU6ICdaJyxcbiAgICAgICAgICAgIGNoYXJzZXQ6ICd1dGY4bWI0JyxcbiAgICAgICAgICAgIHR5cGVDYXN0LFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQge3NxbE1vZGUsZm9yZWlnbktleUNoZWNrcyxzYWZlVXBkYXRlcyxwcmludFF1ZXJpZXMsaW5pdFNxbCwuLi5vdGhlcn0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgLy8gY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAgICB0aGlzLnBvb2wgPSBteXNxbC5jcmVhdGVQb29sKG90aGVyKTtcblxuICAgICAgICBjb25zdCBjb25uUXVlcmllcyA9IGluaXRTcWwgPyBbLi4uaW5pdFNxbF0gOiBbXTtcbiAgICAgICAgaWYoc3FsTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25uUXVlcmllcy5wdXNoKHNxbGBTRVQgc3FsX21vZGU9JHtBcnJheS5pc0FycmF5KHNxbE1vZGUpID8gIHNxbE1vZGUuam9pbignLCcpIDogc3FsTW9kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZihmb3JlaWduS2V5Q2hlY2tzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbm5RdWVyaWVzLnB1c2goc3FsYFNFVCBmb3JlaWduX2tleV9jaGVja3M9JHtmb3JlaWduS2V5Q2hlY2tzID8gMSA6IDB9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2FmZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbm5RdWVyaWVzLnB1c2goc3FsYFNFVCBzcWxfc2FmZV91cGRhdGVzPSR7c2FmZVVwZGF0ZXMgPyAxIDogMH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZihjb25uUXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9vbC5vbignY29ubmVjdGlvbicsIChfY29ubjogX1Bvb2xDb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IHRoaXMuX3dyYXAoX2Nvbm4pO1xuICAgICAgICAgICAgICAgIGZvcihjb25zdCBxdWVyeSBvZiBjb25uUXVlcmllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KHF1ZXJ5KTsgLy8gVE9ETzogZG8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGVzZSBxdWVyaWVzIHRvIGZpbmlzaC4uLj9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5PFRSZWNvcmQgZXh0ZW5kcyBvYmplY3Q9UmVjb3JkPHN0cmluZyxhbnk+PihxdWVyeTogU3FsRnJhZyk6IFByb21pc2U8VFJlY29yZFtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb25uZWN0aW9uKGNvbm4gPT4gY29ubi5xdWVyeShxdWVyeSkpXG4gICAgfVxuXG4gICAgZXhlYyhxdWVyeTogU3FsRnJhZyk6IFByb21pc2U8T2tQYWNrZXQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbm5lY3Rpb24oY29ubiA9PiBjb25uLnF1ZXJ5KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBhc3luYyogc3RyZWFtPFRSZWNvcmQgZXh0ZW5kcyBvYmplY3QgPSBSZWNvcmQ8c3RyaW5nLCBhbnk+PihxdWVyeTogU3FsRnJhZyk6IEFzeW5jR2VuZXJhdG9yPFRSZWNvcmQsIHZvaWQsIGFueT4ge1xuICAgICAgICBjb25zdCBzcWwgPSBxdWVyeS50b1NxbFN0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmludFF1ZXJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpc3FsID0gaGlnaGxpZ2h0KHNxbCwge2xhbmd1YWdlOiAnc3FsJywgaWdub3JlSWxsZWdhbHM6IHRydWV9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGhpc3FsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHRzOiBUUmVjb3JkW10gPSBbXTtcbiAgICAgICAgbGV0IHJlc29sdmU6ICgpID0+IHZvaWQ7XG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5wb29sLnF1ZXJ5KHNxbClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ3Jlc3VsdCcsIHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHJlc29sdmUgPSByKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgeWllbGQqIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aXRoQ29ubmVjdGlvbjxUUmVzdWx0PihjYWxsYmFjazogKGNvbm46UG9vbENvbm5lY3Rpb24pID0+IFByb21pc2U8VFJlc3VsdD4pOiBQcm9taXNlPFRSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9vbC5nZXRDb25uZWN0aW9uKGFzeW5jIChlcnIsIGNvbm4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjYWxsYmFjayh0aGlzLl93cmFwKGNvbm4pKSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubi5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb248VFJlc3VsdD4oY2FsbGJhY2s6ICgoY29ubjpQb29sQ29ubmVjdGlvbikgPT4gUHJvbWlzZTxUUmVzdWx0Pil8U3FsRnJhZ1tdKTogUHJvbWlzZTxUUmVzdWx0PiB7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjxhbnk+KGFzeW5jIGNvbm4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoY2FsbGJhY2subWFwKHNxbCA9PiBjb25uLnF1ZXJ5KHNxbCkpKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHppcChjYWxsYmFjaywgcmVzdWx0cykubWFwKCh4LGkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogeFswXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB4WzFdLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IG1hcHBlZC5maWx0ZXIociA9PiByLnJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpO1xuICAgICAgICAgICAgICAgIGlmKGVycm9ycy5sZW5ndGgpIHRocm93IEVycm9yKGAke2Vycm9ycy5sZW5ndGh9IHF1ZXIke2Vycm9ycy5sZW5ndGggPT09IDEgPyAneScgOiAnaWVzJ30gZmFpbGVkOiR7ZXJyb3JzLm1hcChlcnIgPT4gYFxcblske2Vyci5pbmRleH1dICR7ZXJyLnF1ZXJ5LnRvU3FsU3RyaW5nKCl9IDo6ICR7KGVyci5yZXN1bHQgYXMgYW55KS5yZWFzb259YCkuam9pbignJyl9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7IC8vIFRPRE86IGlzIHRoaXMgdGhlIGJlc3QgZm9ybWF0IGZvciB0aGUgcmVzdWx0cz9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb25uZWN0aW9uKGFzeW5jIGNvbm4gPT4ge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShzcWxgU1RBUlQgVFJBTlNBQ1RJT05gKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IFRSZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKGNvbm4pO1xuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KHNxbGBST0xMQkFDS2ApO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoc3FsYENPTU1JVGApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIF93cmFwKGNvbm46IF9Qb29sQ29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBvb2xDb25uZWN0aW9uKGNvbm4sICEhdGhpcy5jb25maWcucHJpbnRRdWVyaWVzKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9vbC5lbmQoZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHppcDxBLEI+KGE6IEFbXSwgYjogQltdKTogQXJyYXk8W0EsQl0+IHtcbiAgICBpZihhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB6aXAgYXJyYXlzOyBsZW5ndGhzIGRpZmZlclwiKTtcbiAgICByZXR1cm4gYS5tYXAoKHgsaSkgPT4gW3gsYltpXV0pO1xufVxuXG5jbGFzcyBQb29sQ29ubmVjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbm46IF9Qb29sQ29ubmVjdGlvbiwgcHJpdmF0ZSByZWFkb25seSBwcmludFF1ZXJpZXM6IGJvb2xlYW4pIHtcblxuICAgIH1cblxuICAgIHF1ZXJ5KHF1ZXJ5OiBTcWxGcmFnKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxbCA9IHF1ZXJ5LnRvU3FsU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoaXNxbCA9IGhpZ2hsaWdodChzcWwsIHtsYW5ndWFnZTogJ3NxbCcsIGlnbm9yZUlsbGVnYWxzOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaGlzcWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uLnF1ZXJ5KHNxbCwgKGVycm9yLCByZXN1bHRzLCBmaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cbn1cbiJdfQ==