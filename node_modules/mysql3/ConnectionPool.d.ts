/// <reference types="node" />
import { PoolConfig as _PoolConfig, FieldInfo as _FieldInfo, Types as _Types } from "mysql";
import { SqlFrag } from './Sql';
import { GeometryType } from "mysql";
import SqlMode from "./SqlMode";
import { PoolConnection as _PoolConnection } from "mysql";
export interface PoolConfig extends Omit<_PoolConfig, 'typeCast' | 'supportBigNumbers' | 'bigNumberStrings'> {
    /**
     * Print SQL queries to STDOUT before executing them.
     */
    printQueries?: boolean;
    typeCast?: (field: FieldInfo, next: NextFn) => any;
    /**
     * @deprecated Set in my.cnf under [mysqld]
     */
    sqlMode?: SqlMode[] | string | null;
    /**
     * Enable or disable foreign key checks for the current session. May ease migration scripts, but not recommended
     * for production usage.
     */
    foreignKeyChecks?: boolean | null;
    /**
     * If this variable is enabled, UPDATE and DELETE statements that do not use a key in the WHERE clause or a LIMIT clause produce an error. This makes it possible to catch UPDATE and DELETE statements where keys are not used properly and that would probably change or delete a large number of rows.
     *
     * @link https://mariadb.com/kb/en/library/server-system-variables/#sql_safe_updates
     * @link https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sql_safe_updates
     * @deprecated Set in my.cnf under [mysqld]
     */
    safeUpdates?: boolean | null;
    /**
     * Array of SQL statements to execute upon connection.
     */
    initSql?: Array<SqlFrag>;
}
export declare type NextFn = () => void;
export declare type Types = keyof typeof _Types;
export declare type FieldInfo = Omit<_FieldInfo, 'type'> & {
    type: Types;
    length: number;
    string(): string | null;
    buffer(): Buffer | null;
    geometry(): GeometryType | null;
};
export interface OkPacket {
    fieldCount: number;
    affectedRows: number;
    insertId: number;
    serverStatus: number;
    warningCount: number;
    message: string;
    protocol41: boolean;
    changedRows: number;
}
export declare class ConnectionPool {
    private pool;
    private readonly config;
    constructor(config: PoolConfig);
    query<TRecord extends object = Record<string, any>>(query: SqlFrag): Promise<TRecord[]>;
    exec(query: SqlFrag): Promise<OkPacket>;
    stream<TRecord extends object = Record<string, any>>(query: SqlFrag): AsyncGenerator<TRecord, void, any>;
    withConnection<TResult>(callback: (conn: PoolConnection) => Promise<TResult>): Promise<TResult>;
    transaction<TResult>(callback: ((conn: PoolConnection) => Promise<TResult>) | SqlFrag[]): Promise<TResult>;
    private _wrap;
    close(): Promise<unknown>;
}
declare class PoolConnection {
    private readonly conn;
    private readonly printQueries;
    constructor(conn: _PoolConnection, printQueries: boolean);
    query(query: SqlFrag): Promise<any>;
}
export {};
